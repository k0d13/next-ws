import type NextNodeServer from 'next/dist/server/next-server.js';

/**
 * Compiles a route pattern into a regular expression.
 * @param routePattern Route pattern, generated by Next.js
 * @returns Regular expression
 */
function compileRoutePattern(routePattern: string) {
  const escapedPattern = routePattern.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  const paramRegex = escapedPattern
    .replace(/\\\[\\\[(?:\\\.){3}([a-z0-9_]+)\\\]\\\]/gi, '?(?<r_o_$1>.+)?') // [[...param]]
    .replace(/\\\[(?:\\\.){3}([a-z0-9_]+)\\\]/gi, '(?<r_$1>.+)') // [...param]
    .replace(/\\\[([a-z0-9_]+)\\\]/gi, '(?<$1>[^/]+)'); // [param]
  return new RegExp(`^${paramRegex}$`);
}

/**
 * Extract the parameters from a request pathname given a route pattern.
 * @param routePattern Route pattern, generated by Next.js
 * @param requestPathname Request pathname
 * @returns Object containing the parameters
 */
function getRouteParams(routePattern: string, requestPathname: string) {
  const routeRegex = compileRoutePattern(routePattern);
  const match = requestPathname.replace(/\/+$/, '').match(routeRegex);
  if (!match) return null;
  if (!match.groups) return {};

  const params: Record<string, string | string[]> = {};
  for (let [k, v] of Object.entries(match.groups)) {
    if (k.startsWith('r_')) {
      const optional = k.startsWith('r_o_');
      k = k.slice(optional ? 4 : 2);
      v = v?.split('/') as never;
    }
    if (v) Reflect.set(params, k, v);
  }
  return params;
}

/**
 * Find the matching route for a given request pathname.
 * @param nextServer Next.js Node server instance
 * @param requestPathname Request pathname
 * @returns Object containing the filename and parameters
 */
export function findMatchingRoute(
  nextServer: NextNodeServer,
  requestPathname: string,
) {
  // @ts-expect-error - serverOptions is protected
  const basePath = nextServer.serverOptions?.conf.basePath || '';
  const appPathRoutes = {
    // @ts-expect-error - appPathRoutes is protected
    ...nextServer.appPathRoutes,
    // @ts-expect-error - getAppPathRoutes is protected
    ...nextServer.getAppPathRoutes(),
  };

  const sortedRoutes = Object.entries(appPathRoutes)
    .filter(([routePath, file]) => routePath && file?.length)
    .sort(([a], [b]) => scoreRoute(b) - scoreRoute(a));

  for (const [routePath, [filePath]] of sortedRoutes) {
    if (!filePath) continue;
    const realPath = `${basePath}${routePath}`;
    const routeParams = getRouteParams(realPath, requestPathname);
    if (routeParams) {
      return { filename: filePath, params: routeParams };
    }
  }
  return undefined;
}

function scoreRoute(routePath: string) {
  const parts = routePath.split('/').filter(Boolean);

  let score = 0;
  // Root path
  if(parts.length === 0) score = Infinity;
  for (const part of parts) {
    // Optional catch-all
    if (part.startsWith('[[...')) score += -1;
    // Catch-all
    else if (part.startsWith('[...')) score += 0;
    else if (part.startsWith('[')) score += 2;
    else score += 3;
  }

  return score + parts.length;
}
